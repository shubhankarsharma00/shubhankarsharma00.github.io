<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: canvasApi.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: canvasApi.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* eslint-disable no-param-reassign */
/**
 * CanvasApi module
 * @module canvasApi
 */
/**
 * Function to help for zooming
 * @param {number} delta - the zooming constant
 * @param {number=|sting} xx - ususally undefined
 * @param {number=|string} yy - usually undefined
 * @param {number} method - 1 for zooming wrt mouse
 * 2,3 for zooming wrt screen
 */
function changeScale(delta, xx, yy, method = 1) {
    if (method === 3) {
        xx = (width / 2 - globalScope.ox) / globalScope.scale;
        yy = (height / 2 - globalScope.oy) / globalScope.scale;
    } else if (
        xx === undefined
        || yy === undefined
        || xx === 'zoomButton'
        || yy === 'zoomButton'
    ) {
        if (
            simulationArea.lastSelected
            &amp;&amp; simulationArea.lastSelected.objectType !== 'Wire'
        ) {
            // selected object
            xx = simulationArea.lastSelected.x;
            yy = simulationArea.lastSelected.y;
        } else {
            // mouse location
            // eslint-disable-next-line no-lonely-if
            if (method === 1) {
                xx = simulationArea.mouseX;
                yy = simulationArea.mouseY;
            } else if (method === 2) {
                xx = (width / 2 - globalScope.ox) / globalScope.scale;
                yy = (height / 2 - globalScope.oy) / globalScope.scale;
            }
        }
    }
    // Shift accordingly, so that we zoom wrt to the selected point
    const oldScale = globalScope.scale;
    globalScope.scale = Math.max(
        0.5,
        Math.min(4 * DPR, globalScope.scale + delta),
    );
    globalScope.scale = Math.round(globalScope.scale * 10) / 10;
    globalScope.ox -= Math.round(xx * (globalScope.scale - oldScale));
    globalScope.oy -= Math.round(yy * (globalScope.scale - oldScale));

    // update MiniMap but not for embed or light mode
    if (!embed &amp;&amp; !lightMode) {
        findDimensions(globalScope);
        miniMapArea.setup();
        $('#miniMap').show();
        lastMiniMapShown = new Date().getTime();
        $('#miniMap').show();
        setTimeout(removeMiniMap, 2000);
    }
}
/**
 * fn to draw Dots on screen
 * the function is called only when the zoom level or size of screen changes.
 * Otherwise for normal panning, the canvas itself is moved to give the illusion of movement
 * @param {boolean} transparentBackground - not used tbd
 * @param {boolean} force -not used tbd
 */

function dots(transparentBackground = false, force = false) {
    var scale = unit * globalScope.scale;
    var ox = globalScope.ox % scale; // offset
    var oy = globalScope.oy % scale; // offset

    document.getElementById('backgroundArea').style.left = (ox - scale) / DPR;
    document.getElementById('backgroundArea').style.top = (oy - scale) / DPR;

    if (globalScope.scale === simulationArea.prevScale &amp;&amp; !force) return;

    if (!backgroundArea.context) return;
    simulationArea.prevScale = globalScope.scale;

    var canvasWidth = backgroundArea.canvas.width; // max X distance
    var canvasHeight = backgroundArea.canvas.height; // max Y distance

    var ctx = backgroundArea.context;
    ctx.beginPath();
    backgroundArea.clear();
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;
    if (!transparentBackground) {
        ctx.fillStyle = 'white';
        ctx.rect(0, 0, canvasWidth, canvasHeight);
        ctx.fill();
    }

    var correction = 0.5 * (ctx.lineWidth % 2);
    for (var i = 0; i &lt; canvasWidth; i += scale) {
        ctx.moveTo(Math.round(i + correction) - correction, 0);
        ctx.lineTo(Math.round(i + correction) - correction, canvasHeight);
    }
    for (var j = 0; j &lt; canvasHeight; j += scale) {
        ctx.moveTo(0, Math.round(j + correction) - correction);
        ctx.lineTo(canvasWidth, Math.round(j + correction) - correction);
    }
    ctx.stroke();

    // old code for archive
    // function drawPixel(x, y, r, g, b, a) {
    //     var index = (x + y * canvasWidth) * 4;
    //     canvasData.data[index + 0] = r;
    //     canvasData.data[index + 1] = g;
    //     canvasData.data[index + 2] = b;
    //     canvasData.data[index + 3] = a;
    // }
    // if (dots) {
    //     var canvasData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
    //
    //
    //
    //     for (var i = 0 + ox; i &lt; canvasWidth; i += scale)
    //         for (var j = 0 + oy; j &lt; canvasHeight; j += scale)
    //             drawPixel(i, j, 0, 0, 0, 255);
    //     ctx.putImageData(canvasData, 0, 0);
    // }
}

// Helper canvas API starts here
// All canvas functions are wrt to a center point (xx,yy),
// direction is used to abstract rotation of everything by a certain angle
// Possible values for direction = "RIGHT" (default), "LEFT", "UP", "DOWN"
/**
 * return actual point which will be center for bezier curve
 * @param {number} x1 - rotate wrt x1 and y1
 * @param {string} y1 - rotate wrt x1 and y1.
 * @param {string} dir - new direction.
 */
function rotate(x1, y1, dir) {
    if (dir === 'LEFT') return [-x1, y1];
    if (dir === 'DOWN') return [y1, x1];
    if (dir === 'UP') return [y1, -x1];
    return [x1, y1];
}

/**
 * function to return a new angles to draw the arc in correct direction.
 * @param {number} start - start angle
 * @param {*} stop - stop angle
 * @param {*} dir - direction
 */
function rotateAngle(start, stop, dir) {
    if (dir === 'LEFT') return [start, stop, true];
    if (dir === 'DOWN') return [start - Math.PI / 2, stop - Math.PI / 2, true];
    if (dir === 'UP') return [start - Math.PI / 2, stop - Math.PI / 2, false];
    return [start, stop, false];
}

/**
 * Function to draw bezier curve
 * @param {number} x1 - x of point 1.
 * @param {number} y1 - y of point 1.
 * @param {number} x2 - x of point 2.
 * @param {number} y2 - y of point 2.
 * @param {number} x3 - x of point 3.
 * @param {number} y3 - y of point 3.
 * @param {number} xx - x bezier point.
 * @param {number} yy - y bezier point.
 * @param {string} dir - direction of the curve.
 */
function bezierCurveTo(x1, y1, x2, y2, x3, y3, xx, yy, dir) {
    const { ox } = globalScope;
    const { oy } = globalScope;
    [x1, y1] = rotate(x1, y1, dir);
    [x2, y2] = rotate(x2, y2, dir);
    [x3, y3] = rotate(x3, y3, dir);
    x1 *= globalScope.scale;
    y1 *= globalScope.scale;
    x2 *= globalScope.scale;
    y2 *= globalScope.scale;
    x3 *= globalScope.scale;
    y3 *= globalScope.scale;
    xx *= globalScope.scale;
    yy *= globalScope.scale;
    ctx.bezierCurveTo(
        Math.round(xx + ox + x1),
        Math.round(yy + oy + y1),
        Math.round(xx + ox + x2),
        Math.round(yy + oy + y2),
        Math.round(xx + ox + x3),
        Math.round(yy + oy + y3),
    );
}

/**
 * we move to xx+-x1 and yy+-y1 according to distance.
 * @param {HTMLCanvasElement} ctx - the working canvas
 * @param {number} x1 - horizontal distance of the path
 * @param {number} y1 - vertical  distance of the path
 * @param {number} xx - x of point from path's beginning
 * @param {number} yy - y of point from path's beginning
 * @param {number} dir - direction of distance
 * @param {boolean} bypass - no correction if true
 */
function moveTo(ctx, x1, y1, xx, yy, dir, bypass = false) {
    var correction = 0.5 * (ctx.lineWidth % 2);
    [newX, newY] = rotate(x1, y1, dir);
    newX *= globalScope.scale;
    newY *= globalScope.scale;
    xx *= globalScope.scale;
    yy *= globalScope.scale;
    if (bypass) {
        ctx.moveTo(xx + globalScope.ox + newX, yy + globalScope.oy + newY);
    } else {
        ctx.moveTo(
            Math.round(xx + globalScope.ox + newX - correction) + correction,
            Math.round(yy + globalScope.oy + newY - correction) + correction,
        );
    }
}

/**
 * we draw a line from xx,yy to  xx+-x1 and yy+-y1 according to distance.
 * @param {HTMLCanvasElement} ctx - the working canvas
 * @param {number} x1 - horizontal distance of the path
 * @param {number} y1 - vertical  distance of the path
 * @param {number} xx - x of point from path's beginning
 * @param {number} yy - y of point from path's beginning
 * @param {number} dir - direction of distance
 */
function lineTo(ctx, x1, y1, xx, yy, dir) {
    var correction = 0.5 * (ctx.lineWidth % 2);
    [newX, newY] = rotate(x1, y1, dir);
    newX *= globalScope.scale;
    newY *= globalScope.scale;
    xx *= globalScope.scale;
    yy *= globalScope.scale;
    ctx.lineTo(
        Math.round(xx + globalScope.ox + newX - correction) + correction,
        Math.round(yy + globalScope.oy + newY - correction) + correction,
    );
}

/**
 * Function to draw an arc
 * @param {HTMLCanvasElement} ctx
 * @param {number} sx - shift in x from element
 * @param {number} sy - shift in y from element
 * @param {number} radius
 * @param {number} start - starting angle
 * @param {number} stop - starting angle
 * @param {number} xx - center x cordinate
 * @param {number} yy -center y cordinate
 * @param {string} dir - direction of the side of curve
 * ox-x of origin
 */
function arc(ctx, sx, sy, radius, start, stop, xx, yy, dir) {
    var correction = 0.5 * (ctx.lineWidth % 2);
    [Sx, Sy] = rotate(sx, sy, dir);
    Sx *= globalScope.scale;
    Sy *= globalScope.scale;
    xx *= globalScope.scale;
    yy *= globalScope.scale;
    radius *= globalScope.scale;
    [newStart, newStop, counterClock] = rotateAngle(start, stop, dir);
    ctx.arc(
        Math.round(xx + globalScope.ox + Sx + correction) - correction,
        Math.round(yy + globalScope.oy + Sy + correction) - correction,
        Math.round(radius),
        newStart,
        newStop,
        counterClock,
    );
}

/**
 * function to built arcs with clock
 * @param {HTMLCanvasElement} ctx
 * @param {number} sx - shift in x direction
 * @param {number} sy -shift in y direction
 * @param {number} radius
 * @param {number} start - start angle
 * @param {number} stop - stop angle
 * @param {number} xx -starting x
 * @param {number} yy - starting y
 * @param {string} dir
 */
function arc2(ctx, sx, sy, radius, start, stop, xx, yy, dir) {
    // ox-x of origin
    var correction = 0.5 * (ctx.lineWidth % 2);
    [Sx, Sy] = rotate(sx, sy, dir);
    Sx *= globalScope.scale;
    Sy *= globalScope.scale;
    xx *= globalScope.scale;
    yy *= globalScope.scale;
    radius *= globalScope.scale;
    [newStart, newStop, counterClock] = rotateAngle(start, stop, dir);
    var pi = 0;
    if (counterClock) {
        pi = Math.PI;
    }
    ctx.arc(
        Math.round(xx + globalScope.ox + Sx + correction) - correction,
        Math.round(yy + globalScope.oy + Sy + correction) - correction,
        Math.round(radius),
        newStart + pi,
        newStop + pi,
    );
}

/**
 * function to draw filled circles like nodes.
 * @param {HTMLCanvasElement} ctx
 * @param {number} sx - shift in x direction
 * @param {number} sy -shift in y direction
 * @param {number} r - radius
 * @param {string} color - color of the circle
 */
function drawCircle(ctx, x1, y1, r, color) {
    x1 *= globalScope.scale;
    y1 *= globalScope.scale;
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(
        Math.round(x1 + globalScope.ox),
        Math.round(y1 + globalScope.oy),
        Math.round(r * globalScope.scale),
        0,
        Math.PI * 2,
        false,
    );
    ctx.closePath();
    ctx.fill();
}

/**
 * function to draw circles that are not filled like the tip of nand or xnor gate.
 * @param {HTMLCanvasElement} ctx
 * @param {number} sx - shift in x direction
 * @param {number} sy -shift in y direction
 * @param {number} radius
 * @param {number} xx -starting x
 * @param {number} yy - starting y
 * @param {string} dir
 */
function drawCircle2(ctx, sx, sy, radius, xx, yy, dir) {
    [Sx, Sy] = rotate(sx, sy, dir);
    Sx *= globalScope.scale;
    Sy *= globalScope.scale;
    xx *= globalScope.scale;
    yy *= globalScope.scale;
    radius *= globalScope.scale;
    ctx.arc(
        Math.round(xx + globalScope.ox + Sx),
        Math.round(yy + globalScope.oy + Sy),
        Math.round(radius),
        0,
        2 * Math.PI,
    );
}

/**
 * function to draw a rectangle
 * @param {HTMLCanvasElement} ctx
 * @param {number} x1 shift of rectangles
 * @param {number} y1 shift of rectangles
 * @param {number} x2 shift of rectangles
 * @param {number} y2 shift of rectangles
 */
function rect(ctx, x1, y1, x2, y2) {
    var correction = 0.5 * (ctx.lineWidth % 2);
    x1 *= globalScope.scale;
    y1 *= globalScope.scale;
    x2 *= globalScope.scale;
    y2 *= globalScope.scale;
    ctx.rect(
        Math.round(globalScope.ox + x1 - correction) + correction,
        Math.round(globalScope.oy + y1 - correction) + correction,
        Math.round(x2),
        Math.round(y2),
    );
}

/**
 * another helper function to draw a rectangle in front of an element
 * @param {HTMLCanvasElement} ctx
 * @param {number} x1 shift of the rectangle from xx and yy
 * @param {number} y1 shift of the rectangle from xx and yy
 * @param {number} x2 shift of the rectangle from xx and yy
 * @param {number} y2 shift of the rectangle from xx and yy
 * @param {number} xx x of element
 * @param {number} yy y of element
 */
function rect2(ctx, x1, y1, x2, y2, xx, yy, dir = 'RIGHT') {
    var correction = 0.5 * (ctx.lineWidth % 2);
    [x1, y1] = rotate(x1, y1, dir);
    [x2, y2] = rotate(x2, y2, dir);
    x1 *= globalScope.scale;
    y1 *= globalScope.scale;
    x2 *= globalScope.scale;
    y2 *= globalScope.scale;
    xx *= globalScope.scale;
    yy *= globalScope.scale;
    ctx.rect(
        Math.round(globalScope.ox + xx + x1 - correction) + correction,
        Math.round(globalScope.oy + yy + y1 - correction) + correction,
        Math.round(x2),
        Math.round(y2),
    );
}

/**
 * getting the maximum width
 * @param {number} w -given width
 */
function correctWidth(w) {
    return Math.max(1, Math.round(w * globalScope.scale));
}

/**
 * function to draw a line
 * @param {HTMLCanvasElement} ctx
 * @param {number} x1 - x of point 1
 * @param {number} y1 - y of point 1
 * @param {number} x2 - x of point 2
 * @param {number} y2 - y of point 2
 * @param {string} color - color of the line
 * @param {number} width - width of the line
 */
function drawLine(ctx, x1, y1, x2, y2, color, width) {
    x1 *= globalScope.scale;
    y1 *= globalScope.scale;
    x2 *= globalScope.scale;
    y2 *= globalScope.scale;
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineCap = 'round';
    ctx.lineWidth = correctWidth(width); //* globalScope.scale;
    var correction = 0.5 * (ctx.lineWidth % 2);
    var hCorrection = 0;
    var vCorrection = 0;
    if (y1 === y2) vCorrection = correction;
    if (x1 === x2) hCorrection = correction;
    ctx.moveTo(
        Math.round(x1 + globalScope.ox + hCorrection) - hCorrection,
        Math.round(y1 + globalScope.oy + vCorrection) - vCorrection,
    );
    ctx.lineTo(
        Math.round(x2 + globalScope.ox + hCorrection) - hCorrection,
        Math.round(y2 + globalScope.oy + vCorrection) - vCorrection,
    );
    ctx.stroke();
}

/**
 * function to check if string color is a valid color using a hack
 * @param {string} color - color to be checked
 */
function validColor(color) {
    var $div = $('&lt;div>');
    $div.css('border', `1px solid ${color}`);
    return $div.css('border-color') !== '';
}

/**
 * helper function to color "RED" to RGBA
 * @param {string} color - color to be converted
 */
function colorToRGBA(color) {
    var cvs;
    var ctx;
    cvs = document.createElement('canvas');
    cvs.height = 1;
    cvs.width = 1;
    ctx = cvs.getContext('2d');
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, 1, 1);
    return ctx.getImageData(0, 0, 1, 1).data;
}

/**
 * Helper function to show message like values, node name etc
 * @param {HTMLCanvasElement} ctx
 * @param {string} str - message string
 * @param {number} x1 - x cordinate of div to show message
 * @param {number} y1 - y cordinate of div to show message
 * @param {number} fontSize
 */
function canvasMessage(ctx, str, x1, y1, fontSize = 10) {
    if (!str || !str.length) return;

    ctx.font = `${Math.round(fontSize * globalScope.scale)}px Georgia`;
    ctx.textAlign = 'center';
    var width = ctx.measureText(str).width / globalScope.scale + 8;
    var height = 13;
    ctx.strokeStyle = 'black';
    ctx.lineWidth = correctWidth(1);
    ctx.fillStyle = 'yellow';
    ctx.save();
    ctx.beginPath();
    rect(ctx, x1 - width / 2, y1 - height / 2 - 3, width, height);
    ctx.shadowColor = '#999';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetX = 3;
    ctx.shadowOffsetY = 3;
    ctx.stroke();
    ctx.fill();
    ctx.restore();
    x1 *= globalScope.scale;
    y1 *= globalScope.scale;
    ctx.beginPath();
    ctx.fillStyle = 'black';
    ctx.fillText(
        str,
        Math.round(x1 + globalScope.ox),
        Math.round(y1 + globalScope.oy),
    );
    ctx.fill();
}

/**
 * One way to fill text in labels
 * @param {HTMLCanvasElement} ctx
 * @param {string} str - message string
 * @param {number} x1 - x cordinate of div to fill text
 * @param {number} y1 - y cordinate of div to fill text
 * @param {number=} fontSize - font size
 */
function fillText(ctx, str, x1, y1, fontSize = 20) {
    x1 *= globalScope.scale;
    y1 *= globalScope.scale;
    ctx.font = `${Math.round(fontSize * globalScope.scale)}px Georgia`;
    ctx.fillText(
        str,
        Math.round(x1 + globalScope.ox),
        Math.round(y1 + globalScope.oy),
    );
}

/**
 * One way to fill text out of 4
 * @param {HTMLCanvasElement} ctx
 * @param {string} str - message
 * @param {number} x1 - shift in x
 * @param {number} y1 - shift in y
 * @param {number} xx - x cordinate of element
 * @param {number} yy - y cordinate of element
 * @param {string} dir - the direction of the text
 */
function fillText2(ctx, str, x1, y1, xx, yy, dir) {
    angle = {
        RIGHT: 0,
        LEFT: 0,
        DOWN: Math.PI / 2,
        UP: -Math.PI / 2,
    };
    x1 *= globalScope.scale;
    y1 *= globalScope.scale;
    [x1, y1] = rotate(x1, y1, dir);
    xx *= globalScope.scale;
    yy *= globalScope.scale;
    ctx.font = `${Math.round(14 * globalScope.scale)}px Georgia`;
    ctx.save();
    ctx.translate(
        Math.round(xx + x1 + globalScope.ox),
        Math.round(yy + y1 + globalScope.oy),
    );
    ctx.rotate(angle[dir]);
    ctx.textAlign = 'center';
    ctx.fillText(
        str,
        0,
        Math.round(4 * globalScope.scale) * (1 - 0 * +(dir === 'DOWN')),
    );
    ctx.restore();
}

/**
 * One way to fill text out of 4
 * @param {HTMLCanvasElement} ctx
 * @param {string} str - message
 * @param {number} x1 - shift in x
 * @param {number} y1 - shift in y
 * @param {number=} xx - x cordinate of element
 * @param {number=} yy - y cordinate of element
 * @param {number} fontSize - the font size of the text
 * @param {string=} font - the font of the text
 * @param {string=} textAlign - the alignment of the text
 */
function fillText3(
    ctx,
    str,
    x1,
    y1,
    xx = 0,
    yy = 0,
    fontSize = 14,
    font = 'Georgia',
    textAlign = 'center',
) {
    x1 *= globalScope.scale;
    y1 *= globalScope.scale;
    xx *= globalScope.scale;
    yy *= globalScope.scale;

    ctx.font = `${Math.round(fontSize * globalScope.scale)}px ${font}`;
    ctx.textAlign = textAlign;
    ctx.fillText(
        str,
        Math.round(xx + x1 + globalScope.ox),
        Math.round(yy + y1 + globalScope.oy),
    );
}

/**
 * One way to fill text out of 4
 * @param {HTMLCanvasElement} ctx
 * @param {string} str - message
 * @param {number} x1 - shift in x
 * @param {number} y1 - shift in y
 * @param {number} xx - x cordinate of element
 * @param {number} yy - y cordinate of element
 * @param {string} dir - the direction of the text
 * @param {number} fontSize - the font size of the text
 * @param {string=} textAlign - the alignment of the text
 */
function fillText4(
    ctx,
    str,
    x1,
    y1,
    xx,
    yy,
    dir,
    fontSize = 14,
    textAlign = 'center',
) {
    angle = {
        RIGHT: 0,
        LEFT: 0,
        DOWN: Math.PI / 2,
        UP: -Math.PI / 2,
    };
    x1 *= globalScope.scale;
    y1 *= globalScope.scale;
    [x1, y1] = rotate(x1, y1, dir);
    xx *= globalScope.scale;
    yy *= globalScope.scale;

    ctx.font = `${Math.round(fontSize * globalScope.scale)}px Georgia`;
    // ctx.font = 20+"px Georgia";
    ctx.textAlign = textAlign;
    ctx.fillText(
        str,
        xx + x1 + globalScope.ox,
        yy
            + y1
            + globalScope.oy
            + Math.round((fontSize / 3) * globalScope.scale),
    );
}

oppositeDirection = {
    RIGHT: 'LEFT',
    LEFT: 'RIGHT',
    DOWN: 'UP',
    UP: 'DOWN',
};
fixDirection = {
    right: 'LEFT',
    left: 'RIGHT',
    down: 'UP',
    up: 'DOWN',
    LEFT: 'LEFT',
    RIGHT: 'RIGHT',
    UP: 'UP',
    DOWN: 'DOWN',
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-canvasApi.html">canvasApi</a></li><li><a href="module-data.html">data</a></li><li><a href="module-engine.html">engine</a></li><li><a href="module-eventQueue.html">eventQueue</a></li><li><a href="module-modules.html">modules</a></li><li><a href="module-node.html">node</a></li><li><a href="module-wire.html">wire</a></li></ul><h3>Classes</h3><ul><li><a href="CircuitElement.html">CircuitElement</a></li><li><a href="Clock.html">Clock</a></li><li><a href="DflipFlop.html">DflipFlop</a></li><li><a href="Dlatch.html">Dlatch</a></li><li><a href="JKflipFlop.html">JKflipFlop</a></li><li><a href="Keyboard.html">Keyboard</a></li><li><a href="layoutNode.html">layoutNode</a></li><li><a href="module-eventQueue-EventQueue.html">EventQueue</a></li><li><a href="module-modules-Adder.html">Adder</a></li><li><a href="module-modules-ALU.html">ALU</a></li><li><a href="module-modules-AndGate.html">AndGate</a></li><li><a href="module-modules-Arrow.html">Arrow</a></li><li><a href="module-modules-BitSelector.html">BitSelector</a></li><li><a href="module-modules-Buffer.html">Buffer</a></li><li><a href="module-modules-Button.html">Button</a></li><li><a href="module-modules-ConstantVal.html">ConstantVal</a></li><li><a href="module-modules-ControlledInverter.html">ControlledInverter</a></li><li><a href="module-modules-Decoder.html">Decoder</a></li><li><a href="module-modules-Demultiplexer.html">Demultiplexer</a></li><li><a href="module-modules-DigitalLed.html">DigitalLed</a></li><li><a href="module-modules-Flag.html">Flag</a></li><li><a href="module-modules-ForceGate.html">ForceGate</a></li><li><a href="module-modules-Ground.html">Ground</a></li><li><a href="module-modules-HexDisplay.html">HexDisplay</a></li><li><a href="module-modules-Input.html">Input</a></li><li><a href="module-modules-LSB.html">LSB</a></li><li><a href="module-modules-MSB.html">MSB</a></li><li><a href="module-modules-Multiplexer.html">Multiplexer</a></li><li><a href="module-modules-NandGate.html">NandGate</a></li><li><a href="module-modules-NorGate.html">NorGate</a></li><li><a href="module-modules-NotGate.html">NotGate</a></li><li><a href="module-modules-OrGate.html">OrGate</a></li><li><a href="module-modules-Output.html">Output</a></li><li><a href="module-modules-Power.html">Power</a></li><li><a href="module-modules-PriorityEncoder.html">PriorityEncoder</a></li><li><a href="module-modules-Rectangle.html">Rectangle</a></li><li><a href="module-modules-RGBLed.html">RGBLed</a></li><li><a href="module-modules-Rom.html">Rom</a></li><li><a href="module-modules-SevenSegDisplay.html">SevenSegDisplay</a></li><li><a href="module-modules-SixteenSegDisplay.html">SixteenSegDisplay</a></li><li><a href="module-modules-Splitter.html">Splitter</a></li><li><a href="module-modules-SquareRGBLed.html">SquareRGBLed</a></li><li><a href="module-modules-Stepper.html">Stepper</a></li><li><a href="module-modules-Text.html">Text</a></li><li><a href="module-modules-TriState.html">TriState</a></li><li><a href="module-modules-Tunnel.html">Tunnel</a></li><li><a href="module-modules-TwoComplement.html">TwoComplement</a></li><li><a href="module-modules-VariableLed.html">VariableLed</a></li><li><a href="module-modules-XnorGate.html">XnorGate</a></li><li><a href="module-modules-XorGate.html">XorGate</a></li><li><a href="module-node.Node.html">Node</a></li><li><a href="module-wire.Wire.html">Wire</a></li><li><a href="Random.html">Random</a></li><li><a href="Scope.html">Scope</a></li><li><a href="SRflipFlop.html">SRflipFlop</a></li><li><a href="StopWatch.html">StopWatch</a></li><li><a href="SubCircuit.html">SubCircuit</a></li><li><a href="TB_Input.html">TB_Input</a></li><li><a href="TB_Output.html">TB_Output</a></li><li><a href="TflipFlop.html">TflipFlop</a></li><li><a href="TTY.html">TTY</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addPlot">addPlot</a></li><li><a href="global.html#cancelLayout">cancelLayout</a></li><li><a href="global.html#changeClockEnable">changeClockEnable</a></li><li><a href="global.html#changeLightMode">changeLightMode</a></li><li><a href="global.html#clockTick">clockTick</a></li><li><a href="global.html#copy">copy</a></li><li><a href="global.html#Counter">Counter</a></li><li><a href="global.html#createBooleanPrompt">createBooleanPrompt</a></li><li><a href="global.html#createCombinationalAnalysisPrompt">createCombinationalAnalysisPrompt</a></li><li><a href="global.html#cut">cut</a></li><li><a href="global.html#decreaseLayoutHeight">decreaseLayoutHeight</a></li><li><a href="global.html#decreaseLayoutWidth">decreaseLayoutWidth</a></li><li><a href="global.html#determine_label">determine_label</a></li><li><a href="global.html#distance">distance</a></li><li><a href="global.html#DPR">DPR</a></li><li><a href="global.html#EEPROM">EEPROM</a></li><li><a href="global.html#errorDetected">errorDetected</a></li><li><a href="global.html#forceResetNodes">forceResetNodes</a></li><li><a href="global.html#globalScope">globalScope</a></li><li><a href="global.html#gridUpdate">gridUpdate</a></li><li><a href="global.html#height">height</a></li><li><a href="global.html#hideRestricted">hideRestricted</a></li><li><a href="global.html#increaseLayoutHeight">increaseLayoutHeight</a></li><li><a href="global.html#increaseLayoutWidth">increaseLayoutWidth</a></li><li><a href="global.html#layout_buffer">layout_buffer</a></li><li><a href="global.html#layoutMode">layoutMode</a></li><li><a href="global.html#layoutResetNodes">layoutResetNodes</a></li><li><a href="global.html#layoutTitleDown">layoutTitleDown</a></li><li><a href="global.html#layoutTitleLeft">layoutTitleLeft</a></li><li><a href="global.html#layoutTitleRight">layoutTitleRight</a></li><li><a href="global.html#layoutTitleUp">layoutTitleUp</a></li><li><a href="global.html#layoutUpdate">layoutUpdate</a></li><li><a href="global.html#lightMode">lightMode</a></li><li><a href="global.html#loading">loading</a></li><li><a href="global.html#loadSubCircuit">loadSubCircuit</a></li><li><a href="global.html#objectSelection">objectSelection</a></li><li><a href="global.html#openInNewTab">openInNewTab</a></li><li><a href="global.html#paneLayout">paneLayout</a></li><li><a href="global.html#paste">paste</a></li><li><a href="global.html#prevErrorMessage">prevErrorMessage</a></li><li><a href="global.html#prevShowMessage">prevShowMessage</a></li><li><a href="global.html#projectSaved">projectSaved</a></li><li><a href="global.html#RAM">RAM</a></li><li><a href="global.html#recoverProject">recoverProject</a></li><li><a href="global.html#renderLayout">renderLayout</a></li><li><a href="global.html#resetup">resetup</a></li><li><a href="global.html#returntheverilogfortheproject">return the verilog for the project</a></li><li><a href="global.html#runTest">runTest</a></li><li><a href="global.html#saveLayout">saveLayout</a></li><li><a href="global.html#scopeList">scopeList</a></li><li><a href="global.html#selectAll">selectAll</a></li><li><a href="global.html#setup">setup</a></li><li><a href="global.html#setupElementLists">setupElementLists</a></li><li><a href="global.html#setupEnvironment">setupEnvironment</a></li><li><a href="global.html#setupUI">setupUI</a></li><li><a href="global.html#showError">showError</a></li><li><a href="global.html#showMessage">showMessage</a></li><li><a href="global.html#showRestricted">showRestricted</a></li><li><a href="global.html#startListeners">startListeners</a></li><li><a href="global.html#startPlot">startPlot</a></li><li><a href="global.html#tosetuptheplottingarea">to setup the plotting area</a></li><li><a href="global.html#toupdatetheplot">to update the plot</a></li><li><a href="global.html#toggleLayoutMode">toggleLayoutMode</a></li><li><a href="global.html#toggleLayoutTitle">toggleLayoutTitle</a></li><li><a href="global.html#uniq">uniq</a></li><li><a href="global.html#uniqueIdCounter">uniqueIdCounter</a></li><li><a href="global.html#unit">unit</a></li><li><a href="global.html#updateCanvas">updateCanvas</a></li><li><a href="global.html#updatePosition">updatePosition</a></li><li><a href="global.html#updateRestrictedElementsInScope">updateRestrictedElementsInScope</a></li><li><a href="global.html#updateRestrictedElementsList">updateRestrictedElementsList</a></li><li><a href="global.html#updateSimulation">updateSimulation</a></li><li><a href="global.html#updateSubcircuit">updateSubcircuit</a></li><li><a href="global.html#width">width</a></li><li><a href="global.html#willBeUpdated">willBeUpdated</a></li><li><a href="global.html#wireToBeChecked">wireToBeChecked</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Wed May 20 2020 15:07:41 GMT+0530 (India Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
